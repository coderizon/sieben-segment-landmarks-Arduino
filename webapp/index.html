<!DOCTYPE html>
<html>
<head>
  <title>Mein Gesten-Erkenner (mit Visualisierung)</title>
  <style>
    body { font-family: sans-serif; text-align: center; padding: 20px; }
    
    /* Container hält Video und Canvas zusammen */
    .container { 
      position: relative; 
      display: inline-block; 
      width: 640px; 
      height: 480px; 
      border-radius: 12px;
      overflow: hidden;
      box-shadow: 0 12px 30px rgba(0, 0, 0, 0.25);
    }

    /* Beide Elemente liegen exakt übereinander und sind gespiegelt */
    video, canvas { 
      position: absolute; 
      top: 0; 
      left: 0; 
      width: 640px; 
      height: 480px;
      border-radius: 12px; 
      transform: scaleX(-1); /* Spiegeln für Selfie-Modus */
    }

    #output { font-size: 32px; font-weight: bold; margin-top: 20px; color: #007bff; }
    button { padding: 10px 20px; font-size: 16px; cursor: pointer; margin-top: 10px; }
    #bleControls { margin-top: 10px; display: flex; gap: 12px; justify-content: center; align-items: center; }
    #btStatus { font-weight: bold; }
  </style>
</head>
<body>

  <h1>Mein trainiertes Modell testen</h1>
  <p>Status: <span id="status">Lade Modell...</span></p>
  <div id="bleControls">
    <button id="connectButton">Mit Arduino verbinden</button>
    <span id="btStatus">Bluetooth: Nicht verbunden</span>
  </div>
  
  <div class="container">
    <video id="webcam" autoplay playsinline></video>
    <canvas id="output_canvas" width="640" height="480"></canvas>
  </div>
  
  <div id="output">Warte auf Geste...</div>
  <div style="margin-top:10px; display:flex; gap:12px; justify-content:center; align-items:center;">
    <button id="enableWebcamButton">Webcam starten</button>
    <button id="switchCameraButton">Kamera: Front</button>
  </div>

  <script type="module">
    import { GestureRecognizer, FilesetResolver, DrawingUtils } 
        from "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.3";

    let gestureRecognizer;
    let runningMode = "VIDEO";
    let webcamRunning = false;
    const video = document.getElementById("webcam");
    const canvasElement = document.getElementById("output_canvas");
    const canvasCtx = canvasElement.getContext("2d");
    const outputDiv = document.getElementById("output");
    const statusSpan = document.getElementById("status");
    const enableWebcamButton = document.getElementById("enableWebcamButton");
    const switchCameraButton = document.getElementById("switchCameraButton");
    const connectButton = document.getElementById("connectButton");
    const btStatus = document.getElementById("btStatus");
    const isMobile = /Android|iPhone|iPad|iPod/i.test(navigator.userAgent);
    let currentFacingMode = "user"; // "user" = Front, "environment" = Rückkamera
    let lastSentTotal = null;
    let lastSendTime = 0;
    let animationRequestId = null;

    // BLE Konstanten (Nordic UART Service)
    const ARDUINO_UART_SERVICE_UUID = "6e400001-b5a3-f393-e0a9-e50e24dcca9e";
    const ARDUINO_UART_WRITE_CHARACTERISTIC_CANDIDATES = [
      "6e400002-b5a3-f393-e0a9-e50e24dcca9e",
      "6e400003-b5a3-f393-e0a9-e50e24dcca9e"
    ];
    const ARDUINO_NAME_PREFIXES = ["Arduino UNO R4", "UNO R4", "Arduino UNO"];
    let arduinoDevice = null;
    let arduinoServer = null;
    let arduinoUartService = null;
    let arduinoUartCharacteristic = null;

    // Initialisiere die Zeichen-Tools
    const drawingUtils = new DrawingUtils(canvasCtx);

    // Button erst aktivieren, wenn das Modell geladen ist
    enableWebcamButton.disabled = true;
    if (!isMobile) {
      switchCameraButton.style.display = "none";
    }

    function updateCameraButtonLabel() {
      switchCameraButton.textContent = currentFacingMode === "user" ? "Kamera: Front" : "Kamera: Rück";
    }

    function getVideoConstraints() {
      return isMobile
        ? { facingMode: currentFacingMode, width: { ideal: 640 }, height: { ideal: 480 } }
        : true;
    }

    function stopCurrentStream() {
      const stream = video.srcObject;
      if (stream && stream.getTracks) {
        stream.getTracks().forEach(track => track.stop());
      }
    }

    function stopPredictionLoop() {
      webcamRunning = false;
      if (animationRequestId) {
        cancelAnimationFrame(animationRequestId);
        animationRequestId = null;
      }
    }

    function startPredictionLoop() {
      webcamRunning = true;
      predictWebcam();
    }

    const createGestureRecognizer = async () => {
      try {
        const vision = await FilesetResolver.forVisionTasks(
          "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.3/wasm"
        );

        const buildOptions = (delegate) => ({
          baseOptions: {
            modelAssetPath: "./gesture_recognizer.task",
            delegate
          },
          runningMode: runningMode,
          numHands: 2
        });

        const preferredDelegate = isMobile ? "CPU" : "GPU";
        let activeDelegate = preferredDelegate;

        try {
          gestureRecognizer = await GestureRecognizer.createFromOptions(
            vision,
            buildOptions(preferredDelegate)
          );
        } catch (delegateError) {
          // Manche Mobile/Browser blocken GPU, daher CPU-Fallback versuchen.
          if (preferredDelegate !== "CPU") {
            console.warn("GPU-Delegate fehlgeschlagen, fallback auf CPU", delegateError);
            gestureRecognizer = await GestureRecognizer.createFromOptions(
              vision,
              buildOptions("CPU")
            );
            activeDelegate = "CPU";
          } else {
            throw delegateError;
          }
        }

        statusSpan.innerText = `Modell bereit! (${activeDelegate}) Klicke auf Start.`;
        enableWebcamButton.disabled = false;
      } catch (error) {
        console.error("GestureRecognizer konnte nicht initialisiert werden:", error);
        statusSpan.innerText = "Modell konnte nicht geladen werden.";
      }
    };

    createGestureRecognizer();

    enableWebcamButton.addEventListener("click", async () => {
      if (!gestureRecognizer) { alert("Warte auf Modell..."); return; }
      enableWebcamButton.style.display = "none";

      try {
        stopCurrentStream();
        const stream = await navigator.mediaDevices.getUserMedia({ video: getVideoConstraints() });
        video.srcObject = stream;
        video.addEventListener("loadeddata", startPredictionLoop, { once: true });
      } catch (err) {
        console.error("Kamera konnte nicht gestartet werden:", err);
        alert("Kamera konnte nicht gestartet werden.");
        stopPredictionLoop();
        enableWebcamButton.style.display = "inline-block";
      }
    });

    switchCameraButton.addEventListener("click", async () => {
      if (!isMobile) { return; }
      currentFacingMode = currentFacingMode === "user" ? "environment" : "user";
      updateCameraButtonLabel();
      if (!webcamRunning) { return; }
      try {
        stopPredictionLoop();
        stopCurrentStream();
        const stream = await navigator.mediaDevices.getUserMedia({ video: getVideoConstraints() });
        video.srcObject = stream;
        video.addEventListener("loadeddata", startPredictionLoop, { once: true });
      } catch (err) {
        console.error("Kamerawechsel fehlgeschlagen, wechsle zurück auf Front:", err);
        currentFacingMode = "user";
        updateCameraButtonLabel();
        try {
          stopPredictionLoop();
          const fallbackStream = await navigator.mediaDevices.getUserMedia({ video: getVideoConstraints() });
          video.srcObject = fallbackStream;
          video.addEventListener("loadeddata", startPredictionLoop, { once: true });
        } catch (fallbackErr) {
          console.error("Fallback auf Frontkamera fehlgeschlagen:", fallbackErr);
          alert("Kamera konnte nicht gewechselt werden.");
        }
      }
    });

    updateCameraButtonLabel();

    async function predictWebcam() {
      if (runningMode === "IMAGE") {
        runningMode = "VIDEO";
        await gestureRecognizer.setOptions({ runningMode: "VIDEO" });
      }

      // Warten, bis Video-Frames bereit sind
      if (!video.srcObject || video.videoWidth === 0 || video.videoHeight === 0) {
        animationRequestId = window.requestAnimationFrame(predictWebcam);
        return;
      }

      let results;
      try {
        const nowInMs = Date.now();
        results = gestureRecognizer.recognizeForVideo(video, nowInMs);
      } catch (err) {
        console.warn("Erkennung übersprungen (Video evtl. noch nicht bereit):", err);
        animationRequestId = window.requestAnimationFrame(predictWebcam);
        return;
      }

      // --- HIER BEGINNT DIE VISUALISIERUNG ---
      
      // 1. Canvas leeren (vom vorherigen Frame)
      canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);

      // 2. Wenn Hände erkannt wurden, male sie
      if (results.landmarks && results.landmarks.length > 0) {
        for (const landmarks of results.landmarks) {
          
          // Zeichne die Verbindungen (Knochen)
          drawingUtils.drawConnectors(
            landmarks,
            GestureRecognizer.HAND_CONNECTIONS,
            { color: "#00FF00", lineWidth: 3 } // Grüne Linien
          );

          // Zeichne die Punkte (Gelenke)
          drawingUtils.drawLandmarks(
            landmarks,
            { color: "#FF0000", lineWidth: 2, radius: 3 } // Rote Punkte
          );
        }
      }
      // --- ENDE VISUALISIERUNG ---

      if (results.gestures && results.gestures.length > 0) {
        const hands = results.gestures.map((g, idx) => {
          const { categoryName, score } = g[0];
          const value = Number.parseInt(categoryName, 10);
          return {
            label: categoryName,
            score: Math.round(score * 100),
            value: Number.isNaN(value) ? 0 : value,
            index: idx + 1
          };
        });

        const total = hands.reduce((sum, h) => sum + h.value, 0);
        outputDiv.innerText = `Finger angezeigt: ${total}`;

        // An Arduino senden, wenn Wert sich geändert hat (kleines Throttling)
        const now = Date.now();
        if (total !== lastSentTotal && now - lastSendTime > 300) {
          sendToArduino(total.toString());
          lastSentTotal = total;
          lastSendTime = now;
        }
      } else {
        outputDiv.innerText = "Keine Hand erkannt";
      }

      if (webcamRunning) {
        animationRequestId = window.requestAnimationFrame(predictWebcam);
      }
    }

    // --- Web Bluetooth ---
    function buildArduinoFilters() {
      const filters = ARDUINO_NAME_PREFIXES.map(prefix => ({
        namePrefix: prefix,
        services: [ARDUINO_UART_SERVICE_UUID]
      }));
      filters.push({ services: [ARDUINO_UART_SERVICE_UUID] });
      return filters;
    }

    async function connectArduino() {
      try {
        arduinoDevice = await navigator.bluetooth.requestDevice({
          filters: buildArduinoFilters(),
          optionalServices: [ARDUINO_UART_SERVICE_UUID]
        });

        arduinoServer = await arduinoDevice.gatt.connect();
        arduinoUartService = await arduinoServer.getPrimaryService(ARDUINO_UART_SERVICE_UUID);
        arduinoUartCharacteristic = await findArduinoCharacteristic(arduinoUartService);

        setBluetoothConnected(true);
        arduinoDevice.addEventListener("gattserverdisconnected", handleArduinoDisconnect);
      } catch (error) {
        console.error("Fehler beim Verbinden mit dem Arduino UNO R4:", error);
        alert("Arduino UNO R4 konnte nicht verbunden werden. Bitte prüfe den Bluetooth-Status und das laufende Sketch.");
        cleanupArduinoState();
        setBluetoothConnected(false);
      }
    }

    function handleArduinoDisconnect() {
      cleanupArduinoState();
      setBluetoothConnected(false);
    }

    function cleanupArduinoState() {
      arduinoUartCharacteristic = null;
      arduinoUartService = null;
      if (arduinoServer && arduinoServer.connected) {
        arduinoServer.disconnect();
      }
      arduinoServer = null;
      arduinoDevice = null;
    }

    async function findArduinoCharacteristic(service) {
      for (const uuid of ARDUINO_UART_WRITE_CHARACTERISTIC_CANDIDATES) {
        try {
          return await service.getCharacteristic(uuid);
        } catch (_) {
          // try next
        }
      }
      throw new Error("Kein kompatibles UART-Charakteristikum im UNO R4 Service gefunden.");
    }

    async function sendToArduino(text) {
      if (!arduinoUartCharacteristic) {
        return;
      }
      try {
        const data = new TextEncoder().encode(String(text) + "\n");
        await arduinoUartCharacteristic.writeValueWithoutResponse(data);
      } catch (error) {
        console.error("Senden zum Arduino UNO R4 fehlgeschlagen:", error);
      }
    }

    function setBluetoothConnected(isConnected) {
      if (isConnected) {
        btStatus.textContent = "Bluetooth: Verbunden";
        btStatus.style.color = "#28a745";
        connectButton.textContent = "Trennen";
        connectButton.onclick = handleArduinoDisconnect;
      } else {
        btStatus.textContent = "Bluetooth: Nicht verbunden";
        btStatus.style.color = "#dc3545";
        connectButton.textContent = "Mit Arduino verbinden";
        connectButton.onclick = connectArduino;
      }
    }

    if ("bluetooth" in navigator) {
      connectButton.onclick = connectArduino;
    } else {
      connectButton.disabled = true;
      btStatus.textContent = "Web Bluetooth wird von diesem Browser nicht unterstützt.";
    }
  </script>
</body>
</html>
